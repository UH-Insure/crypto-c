m1 <- llvm_load_module "build/aes_wrapper.bc";
m2 <- llvm_load_module "build/aes.bc";
m  <- llvm_link_modules [m1, m2];

let c_fn = llvm_symbol "aes128_ecb_encrypt_one" m;

mb <- get_env "SPEC_FALLBACK";
let do_fallback =
  case mb of
    Just _  -> false;
    Nothing -> true;

if do_fallback then {
  print "SPEC_FALLBACK not set → running AES-128 KAT (FIPS-197 C.1).";

  let key = [0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F] : [16][8];
  let pt  = [0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF] : [16][8];
  let ct_expected = [0x69,0xC4,0xE0,0xD8,0x6A,0x7B,0x04,0x30,0xD8,0xCD,0xB7,0x80,0x70,0xB4,0xC5,0x5A] : [16][8];

  k <- crucible_alloc (llvm_array 16 (llvm_int 8));
  p <- crucible_alloc (llvm_array 16 (llvm_int 8));
  o <- crucible_alloc (llvm_array 16 (llvm_int 8));

  crucible_points_to k (crucible_array (map (llvm_int 8) key));
  crucible_points_to p (crucible_array (map (llvm_int 8) pt));

  _ <- crucible_exec_llvm_func c_fn [k, p, o];

  got <- crucible_read_memory o (llvm_array 16 (llvm_int 8));
  crucible_assert (got == (crucible_array (map (llvm_int 8) ct_expected))) "AES-128 KAT must match expected ciphertext";

  prove_print;
} else {
  print "SPEC_FALLBACK set → running Cryptol equivalence for AES-128.";
  cryptol_path ["external/cryptol-specs"];
  cryptol_load "cryptol/aes128.cry";

  k <- crucible_alloc (llvm_array 16 (llvm_int 8));
  p <- crucible_alloc (llvm_array 16 (llvm_int 8));
  o <- crucible_alloc (llvm_array 16 (llvm_int 8));

  _ <- crucible_exec_llvm_func c_fn [k, p, o];

  c_out <- crucible_read_memory o (llvm_array 16 (llvm_int 8));

  let spec_enc = {{ aes128::aes128_enc }};
  s_out <- spec_enc (crucible_term (crucible_read_memory_term k (llvm_array 16 (llvm_int 8))))
                    (crucible_term (crucible_read_memory_term p (llvm_array 16 (llvm_int 8))));

  crucible_equal c_out (crucible_array (map (llvm_int 8) s_out));
  prove_print;
}