m1 <- llvm_load_module "build/sha_wrapper.bc";
m2 <- llvm_load_module "build/sha256.bc";
m  <- llvm_link_modules [m1, m2];

let c_fn = llvm_symbol "sha256_once" m;

mb <- get_env "SPEC_FALLBACK";
let do_fallback =
  case mb of
    Just _  -> false;
    Nothing -> true;

if do_fallback then {
  print "SPEC_FALLBACK not set → running SHA-256 KAT (empty string).";

  let expected =
    [0xE3,0xB0,0xC4,0x42,0x98,0xFC,0x1C,0x14,0x9A,0xFB,0xF4,0xC8,0x99,0x6F,0xB9,0x24,
     0x27,0xAE,0x41,0xE4,0x64,0x9B,0x93,0x4C,0xA4,0x95,0x99,0x1B,0x78,0x52,0xB8,0x55] : [32][8];

  buf <- crucible_alloc (llvm_array 0 (llvm_int 8));
  out <- crucible_alloc (llvm_array 32 (llvm_int 8));

  _ <- crucible_exec_llvm_func c_fn [buf, (crucible_term {{ 0 : [64] }}), out];

  got <- crucible_read_memory out (llvm_array 32 (llvm_int 8));
  crucible_assert (got == (crucible_array (map (llvm_int 8) expected))) "SHA-256 empty-string digest must match";

  prove_print;
} else {
  print "SPEC_FALLBACK set → running Cryptol equivalence for SHA-256.";
  cryptol_path ["external/cryptol-specs"];
  cryptol_load "cryptol/sha256.cry";

  msg <- crucible_alloc (llvm_array 64 (llvm_int 8));
  out <- crucible_alloc (llvm_array 32 (llvm_int 8));

  _ <- crucible_exec_llvm_func c_fn [msg, (crucible_term {{ 64 : [64] }}), out];

  c_out <- crucible_read_memory out (llvm_array 32 (llvm_int 8));

  let spec = {{ sha256::sha256 }};
  s_out <- spec (crucible_term (crucible_read_memory_term msg (llvm_array 64 (llvm_int 8))));

  crucible_equal c_out (crucible_array (map (llvm_int 8) s_out));
  prove_print;
}